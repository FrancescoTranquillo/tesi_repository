geom_roc(n.cuts=0) +
coord_equal() +
style_roc()
g + annotate("text", x=0.75, y=0.25, label=paste("AUC =", round((calc_auc(g)))))
g <- ggplot(mod0$pred[selectedIndices, ], aes(m=pos, d=factor(obs, levels = c("1", "0")))) +
geom_roc(n.cuts=0) +
coord_equal() +
style_roc()
g + annotate("text", x=0.75, y=0.25, label=paste("AUC =", round((calc_auc(g)))))
g <- ggplot(mod0$pred[selectedIndices, ], aes(m=pred, d=factor(obs, levels = c("1", "0")))) +
geom_roc(n.cuts=0) +
coord_equal() +
style_roc()
g + annotate("text", x=0.75, y=0.25, label=paste("AUC =", round((calc_auc(g)))))
plot(roc(predictor = mod0$pred$pos, response = mod0$pred$obs))
plot(roc(predictor = mod0$pred$pos, response = mod0$pred$obs))
table(testing$TARGET)
testing[which(testing$TARGET=="pos"),]
testing[which(testing$TARGET=="pos")[1:3],]
# sampling = "smote")
#
# svmGrid <-  expand.grid(size=seq(1, 5,1),
#                         decay=seq(0.1,1,0.1))
mod0 <- train(TARGET ~ ., data = training,
method = "nnet",
# tuneGrid = svmGrid,
trControl = fitControl)
mod1 <- train(TARGET ~ ., data = training,
method = "svmLinear",
trControl = fitControl)
mod2 <- train(TARGET ~ ., data = training,
method = "svmRadial",
trControl = fitControl)
mod3 <- train(TARGET ~ ., data = training,
# metric = "Sens",
# maximize = TRUE,
method = "glm",
trControl = fitControl)
mod4 <- train(TARGET ~ ., data = training,
method = "bayesglm",
trControl = fitControl)
compare <- resamples(list(NN=mod0,
SVM.Linear=mod1,
SVM.Radial=mod2,
LogReg=mod3,
BayesLogReg=mod4))
# bwplot(compare,metric="Accuracy")
summary(compare)
scales <- list(x=list(relation="free"), y=list(relation="free"))
bwplot(compare, scales=scales)
# bwplot(compare,metric="Accuracy")
summary(compare)
splom(compare)
scales <- list(x=list(relation="free"), y=list(relation="free"))
bwplot(compare, scales=scales)
predictions <- predict(mod0, testing)
confusionMatrix(predictions, testing$TARGET,mode = "everything",positive = "pos")
table(testing$TARGET)
# sampling = "smote")
#
# svmGrid <-  expand.grid(size=seq(1, 5,1),
#                         decay=seq(0.1,1,0.1))
mod0 <- train(TARGET ~ ., data = training,
metric = "Sens",
maximize = TRUE,
method = "nnet",
# tuneGrid = svmGrid,
trControl = fitControl)
mod1 <- train(TARGET ~ ., data = training,
metric = "Sens",
maximize = TRUE,
method = "svmLinear",
trControl = fitControl)
mod2 <- train(TARGET ~ ., data = training,
metric = "Sens",
maximize = TRUE,
method = "svmRadial",
trControl = fitControl)
mod3 <- train(TARGET ~ ., data = training,
metric = "Sens",
maximize = TRUE,
method = "glm",
trControl = fitControl)
mod4 <- train(TARGET ~ ., data = training,
metric = "Sens",
maximize = TRUE,
method = "bayesglm",
trControl = fitControl)
compare <- resamples(list(NN=mod0,
SVM.Linear=mod1,
SVM.Radial=mod2,
LogReg=mod3,
BayesLogReg=mod4))
# bwplot(compare,metric="Accuracy")
summary(compare)
splom(compare)
scales <- list(x=list(relation="free"), y=list(relation="free"))
bwplot(compare, scales=scales)
predictions <- predict(mod0, testing)
confusionMatrix(predictions, testing$TARGET,mode = "everything",positive = "pos")
predictions <- predict(mod1, testing)
confusionMatrix(predictions, testing$TARGET,mode = "everything",positive = "pos")
predictions <- predict(mod2, testing)
confusionMatrix(predictions, testing$TARGET,mode = "sens_spec",positive = "pos")
predictions <- predict(mod3, testing)
confusionMatrix(predictions, testing$TARGET,mode = "sens_spec",positive = "pos")
predictions <- predict(mod0, testing)
confusionMatrix(predictions, testing$TARGET,mode = "sens_spec",positive = "pos")
predictions <- predict(mod3, testing)
confusionMatrix(predictions, testing$TARGET,mode = "sens_spec",positive = "pos")
predictions <- predict(mod4, testing)
confusionMatrix(predictions, testing$TARGET,mode = "sens_spec",positive = "pos")
compare <- resamples(list(NN=mod0,
SVM.Linear=mod1,
SVM.Radial=mod2,
LogReg=mod3,
BayesLogReg=mod4))
mod5 <- train(TARGET ~ ., data = training,
metric = "Sens",
maximize = TRUE,
method = "rf",
trControl = fitControl)
predictions <- predict(mod5, testing)
confusionMatrix(predictions, testing$TARGET,mode = "sens_spec",positive = "pos")
mod3 <- train(TARGET ~ ., data = training,
metric = "Sens",
maximize = TRUE,
method = "glm",
trControl = fitControl)
predictions <- predict(mod3, testing)
confusionMatrix(predictions, testing$TARGET,mode = "sens_spec",positive = "pos")
predictions <- predict(mod3, testing,type = "prob")
confusionMatrix(predictions, testing$TARGET,mode = "sens_spec",positive = "pos")
predictions
varImp(mod3)
varImp(mod0)
plot(varImp(mod0))
head(predict(dummies, newdata = df_meta_pp))
#one-hot encoding
dummies <- dummyVars(~.,data = df_meta_pp,fullRank = T)
head(predict(dummies, newdata = df_meta_pp))
plot(varImp(mod1))
featurePlot(training, training$TARGET)
featurePlot(training)
source('~/GitHub/tesi_repository/Data/ISA/data_preparation.R', encoding = 'UTF-8')
compare <- resamples(list(NN=mod0,
SVM.Linear=mod1,
SVM.Radial=mod2,
LogReg=mod3,
BayesLogReg=mod4))
compare <- resamples(list(NN=mod0,
SVM.Linear=mod1,
SVM.Radial=mod2,
LogReg=mod3,
BayesLogReg=mod4,
RandomForest=mod5))
bwplot(compare,metric="Accuracy")
bwplot(compare,metric="Sens")
bwplot(compare)
summary(compare)
bwplot(compare)
summary(compare)
predictions <- predict(mod4, testing)
confusionMatrix(predictions, testing$TARGET,mode = "sens_spec",positive = "pos")
obs <- testing[25,]
predict(mod5, obs)
testing[25,59]
obs <- testing[25,1:58]
predict(mod5, obs)
testing[25,59]
testing$TARGET[25]
which(testing$TARGET=="pos")
obs <- testing[910,]
obs
predict(mod0,obs)
obs <- testing[910,1:57]
predict(mod0,obs)
obs <- testing[910,1:58]
predict(mod0,obs)
predict(mod0,obs,type = "prob")
predict(mod1,obs,type = "prob")
predict(mod2,obs,type = "prob")
predict(mod3,obs,type = "prob")
predict(mod4,obs,type = "prob")
predict(mod5,obs,type = "prob")
predict(list(mod0,mod1,mod2),obs,type = "prob",)
confusionMatrix(predict(list(mod0,mod1,mod2),obs),reference = testing$TARGET[910],mode = "sens_spec")
varImp(mod0)
plot(varImp(mod0))
plot(varImp(mod0)[1:10])
plot(varImp(mod0))[1:10]
plot(varImp(mod0)[1])
varImp(mod0)[1]
varImp(mod0)[2]
varImp(mod0)[3]
str(varImp(mod0))
plot(varImp(mod0)[[1:10]])
plot(varImp(mod0)[[1]][1:10])
plot(varImp(mod0)[[1]][1:10,])
plot(varImp(mod0)[1][1:10,])
plot(head(varImp(mod0)))
plot(varImp(mod0)[1])
plot(varImp(mod0))
predictions <- predict(mod0, testing)
confusionMatrix(predictions, testing$TARGET,mode = "sens_spec",positive = "pos")
install.packages("esquisse")
library(esquisse)
#importa tabella degli scontrini
esquisserUI()
#importa tabella degli scontrini
esquisserUI(id = id)
# Lo script unisce la tabella degli scontrini a quella di coswin,
# aggiungendo le colonne chiamata e chiamata-x dove x sono i giorni precedenti
# all'effettiva chiamata
esquisse::esquisser(df)
# Lo script unisce la tabella degli scontrini a quella di coswin,
# aggiungendo le colonne chiamata e chiamata-x dove x sono i giorni precedenti
# all'effettiva chiamata
esquisse::esquisser(df)
ggplot(data = df_bagged) +
aes(x = BAG, y = temp.1) +
geom_boxplot(fill = "#0c4c8a") +
theme_minimal()
# Lo script unisce la tabella degli scontrini a quella di coswin,
# aggiungendo le colonne chiamata e chiamata-x dove x sono i giorni precedenti
# all'effettiva chiamata
esquisse::esquisser(df_bagged)
library(tidyverse)
library(dplyr)
library(lubridate)
library(here)
library(readxl)
library(magrittr)
library(DataExplorer)
library(caret)
library(pROC)
library(esquisse)
df <-
read.csv2(file = "tabella_scontrini_text.csv",
header = T,
stringsAsFactors = F)
#importa tabella degli scontrini
esquisser
# Lo script unisce la tabella degli scontrini a quella di coswin,
# aggiungendo le colonne chiamata e chiamata-x dove x sono i giorni precedenti
# all'effettiva chiamata
esquisse::esquisser(df)
#conversione date e factors
df$INIZIO.CICLO <-
parse_date_time(df$INIZIO.CICLO, orders = "dmy hms")
df$CICLO.REGOLARE <-
factor(df$CICLO.REGOLARE)
df$TIPO.CICLO <- factor(df$TIPO.CICLO)
#caricamento coswin ####
coswin <- read.csv2(file = "coswin-isa/108841.csv",
header = T,
stringsAsFactors = F) %>%
.[-which(grepl("inseri", x = .$Descrizione,ignore.case = T)),24] %>%
as.character(.) %>%
dmy_hm(.) %>%
as_date(.) %>%
.[which(complete.cases(.))] %>%
unique(.)
#aggiunta colonna dei giorni nella tabella di scontrini
df <- df %>%
mutate("GIORNO" = as_date(.$INIZIO.CICLO))
#aggiunta della bag-label
df <- df %>%
mutate("CHIAMATA" = factor(ifelse(.$GIORNO %in% coswin, 1, 0)),
"BAG"=factor(cut.Date(df$GIORNO, breaks = "5 days",labels = F)))
ignore_columns <- c("testo","TEST.DI.TENUTA","NUMERO.CICLO",
"INIZIO.CICLO", "GIORNO")
df_bagged <- df[,-which(names(df) %in% ignore_columns)]
#conversione multipla delle feature da int a fattori
cols = c(38:88, 2)
df_bagged[,cols] %<>% lapply(function(x) fct_explicit_na(as.character(x)))
df_bagged <- df_bagged[,-c(3,6:37)]
#divisione in lista di bags
bags <- as.list(split(df_bagged,f = df_bagged$BAG))
bags_label <- lapply(bags,function(bag){
if(1%in%bag$CHIAMATA){
bags <- list("INSTANCES"=bag, "FLAG"=1)
} else{
bags <- list("INSTANCES"=bag, "FLAG"=0)
}
})
table(factor(lapply(bags_label,function(bag){
s <- bag$FLAG
}) %>% do.call("rbind",.)))
freq_factor <- function(factor_column){
tt <- table(factor_column)
return(names(tt[which.max(tt)]))
}
unify_alarms <- function(alarm_column){
ifelse(1 %in% alarm_column,return(levels(alarm_column)[1]),return(levels(alarm_column)[2]))
}
meta <- function(df_instances){
temps_columns <- grep("temp\\.",names(df_instances))
alarm_columns <- grep("allarm|alarm",names(df_instances),ignore.case = T)
fct <- summarise_all(df_instances[,-c(temps_columns,alarm_columns)],funs(freq_factor(.)))
temps <- summarise_all(df_instances[,temps_columns],mean,na.rm=T)
alarms <- summarise_all(df_instances[,alarm_columns], funs(unify_alarms(.)))
TARGET <- 1
return(cbind(fct,temps,alarms,TARGET))
}
df_meta <- lapply(bags_label,FUN = function(bag){
if(bag$FLAG==1){
meta_example <- meta(bag$INSTANCES)
} else{
examples <- cbind(bag$INSTANCES, TARGET=0)
}
}) %>% do.call("rbind",.)
df_meta_pp <- df_meta[,-which(names(df_meta) %in% c("BAG","CHIAMATA"))]
df_meta_pp$TARGET <- as.numeric(df_meta_pp$TARGET)
#one-hot encoding
dummies <- dummyVars(~.,data = df_meta_pp,fullRank = T)
head(predict(dummies, newdata = df_meta_pp))
dummied <- as.data.frame(predict(dummies, newdata = df_meta_pp))
df_meta_pp <- dummied
#scaling
pp_df_no_nzv <- preProcess(df_meta_pp[ , -which(names(df_meta_pp) %in% "TARGET")],
method = c("range","medianImpute"))
pp_df_no_nzv
data <- predict(pp_df_no_nzv, newdata = df_meta_pp[,-which(names(df_meta_pp) %in% "TARGET")])
View(data)
data$TARGET <- factor(df_meta_pp$TARGET)
levels(data$TARGET) <- c("neg", "pos")
df_meta_pp$TARGET <- factor(df_meta_pp$TARGET)
levels(df_meta_pp$TARGET) <- c("neg", "pos")
#data splitting
trainIndex <- createDataPartition(data$TARGET, p = .75,
list = FALSE,
times = 1)
training <- data[ trainIndex,]
testing <-  data[-trainIndex,]
fitControl <- trainControl(method = "repeatedcv",
number = 10,
repeats = 10,
classProbs = TRUE,
verboseIter=T,allowParallel = T,
summaryFunction = twoClassSummary)
# sampling = "smote")
#
# svmGrid <-  expand.grid(size=seq(1, 5,1),
#                         decay=seq(0.1,1,0.1))
mod0 <- train(TARGET ~ ., data = training,
metric = "Sens",
maximize = TRUE,
method = "nnet",
# tuneGrid = svmGrid,
trControl = fitControl)
plot(mod0)
mod0
predictions <- predict(mod0, testing)
confusionMatrix(predictions, testing$TARGET,mode = "sens_spec",positive = "pos")
testing[1,]
predict(mod0,testing[1,])
mod0
library(NeuralNetTools)
install.packages("NeuralNetTools")
plotnet(mod0$finalModel, y_names = "Target")
library(nnet)
library(nnet)
plotnet(mod0$finalModel, y_names = "Target")
library(NeuralNetTools)
plotnet(mod0$finalModel, y_names = "Target")
plotnet(mod0$finalModel, y_names = "Target")
plot(varImp(mod0)
)
garson(mod0$finalModel)
garson(mod0$finalModel) +
scale_y_continuous('Rel. Importance', limits = c(-1, 1)) +
scale_fill_gradientn(colours = cols) +
scale_colour_gradientn(colours = cols)
garson(mod0$finalModel) +
scale_fill_gradientn(colours = cols) +
scale_colour_gradientn(colours = cols)
mod1 <- train(TARGET ~ ., data = training,
metric = "Sens",
maximize = TRUE,
method = "svmLinear",
trControl = fitControl)
kernlab::plot(mod1$finalModel
)
mod1
kernlab::plot(mod1$finalModel)
kernlab::ksvm(mod1$finalModel)
predictions <- predict(mod0, testing)
svmfit <- svm(TARGET~., data =training, kernel = "linear", scale = FALSE)
library(e1071)        # SVM methodology
library(ISLR)
svmfit <- svm(TARGET~., data =training, kernel = "linear", scale = FALSE)
# Plot Results
plot(svmfit, training)
svmfit <- svm(TARGET~., data =training, kernel = "linear", scale = FALSE)
svmfit
# Plot Results
plot(svmfit, training)
svmfit <- svm(TARGET~., data =training, kernel = "linear", scale = FALSE)
svmfit <- svm(TARGET~., data =data, kernel = "linear", scale = FALSE)
# Plot Results
plot(svmfit, data)
# Plot Results
plot(svmfit, data$`TIPO.CICLO.DISINFEZIONE VELOCE`)
# Plot Results
plot(svmfit, data$`TIPO.CICLO.DISINFEZIONE VELOCE`~data$TIPO.CICLO.CALIBRAZIONE)
mod6 <- train(TARGET ~ ., data = training,
metric = "Sens",
maximize = TRUE,
method = "bartMachine",
trControl = fitControl)
mod6 <- train(TARGET ~ ., data = training,
metric = "Sens",
maximize = TRUE,
method = "bartMachine")
mod7 <- train(TARGET ~ ., data = training,
metric = "Sens",
maximize = TRUE,
method = "knn")
predictions <- predict(mod7, testing)
confusionMatrix(predictions, testing$TARGET,mode = "sens_spec",positive = "pos")
mod7
mod7 <- train(TARGET ~ ., data = training,
metric = "Sens",
maximize = TRUE,
method = "mlpML")
mod7 <- train(TARGET ~ ., data = training,
metric = "Sens",
maximize = TRUE,
method = "mlpML",
trControl = fitControl)
plotnet(mod7$finalModel)
plotnet(mod7$finalModel,training)
mod7
df_meta_pp_notemp <- df_meta_pp[,-c(8,9)]
#scaling
pp_df_no_nzv <- preProcess(df_meta_pp_notemp[ , -which(names(df_meta_pp_notemp) %in% "TARGET")],
method = c("range","medianImpute"))
data <- predict(pp_df_no_nzv, newdata = df_meta_pp_notemp[,-which(names(df_meta_pp_notemp) %in% "TARGET")])
data$TARGET <- factor(df_meta_pp$TARGET)
levels(data$TARGET) <- c("neg", "pos")
df_meta_pp$TARGET <- factor(df_meta_pp$TARGET)
levels(df_meta_pp$TARGET) <- c("neg", "pos")
#data splitting
trainIndex <- createDataPartition(data$TARGET, p = .75,
list = FALSE,
times = 1)
training <- data[ trainIndex,]
testing <-  data[-trainIndex,]
fitControl <- trainControl(method = "repeatedcv",
number = 10,
repeats = 1,
classProbs = TRUE,
verboseIter=T,allowParallel = T,
summaryFunction = twoClassSummary)
# sampling = "smote")
#
# svmGrid <-  expand.grid(size=seq(1, 5,1),
#                         decay=seq(0.1,1,0.1))
mod0 <- train(TARGET ~ ., data = training,
metric = "Sens",
maximize = TRUE,
method = "nnet",
# tuneGrid = svmGrid,
trControl = fitControl)
mod0
predictions <- predict(mod0, testing)
confusionMatrix(predictions, testing$TARGET,mode = "sens_spec",positive = "pos")
rm(list=ls())
source('~/GitHub/tesi_repository/Data/ISA/data_preparation.R', encoding = 'UTF-8')
source('~/GitHub/tesi_repository/Data/ISA/data_preparation.R', encoding = 'UTF-8')
predictions <- predict(mod0, testing)
confusionMatrix(predictions, testing$TARGET,mode = "sens_spec",positive = "pos")
fitControl <- trainControl(method = "repeatedcv",
number = 10,
repeats = 10,
classProbs = TRUE,
verboseIter=T,allowParallel = T,
summaryFunction = twoClassSummary)
# sampling = "smote")
#
# svmGrid <-  expand.grid(size=seq(1, 5,1),
#                         decay=seq(0.1,1,0.1))
mod0 <- train(TARGET ~ ., data = training,
metric = "Sens",
maximize = TRUE,
method = "nnet",
# tuneGrid = svmGrid,
trControl = fitControl)
predictions <- predict(mod0, testing)
confusionMatrix(predictions, testing$TARGET,mode = "sens_spec",positive = "pos")
mod1 <- train(TARGET ~ ., data = training,
metric = "Sens",
maximize = TRUE,
method = "svmLinear",
trControl = fitControl)
predictions <- predict(mod1, testing)
confusionMatrix(predictions, testing$TARGET,mode = "sens_spec",positive = "pos")
#
# mod2 <- train(TARGET ~ ., data = training,
#               metric = "Sens",
#               maximize = TRUE,
#               method = "svmRadial",
#               trControl = fitControl)
#
mod3 <- train(TARGET ~ ., data = training,
metric = "Sens",
maximize = TRUE,
method = "glm",
trControl = fitControl)
predictions <- predict(mod3, testing)
confusionMatrix(predictions, testing$TARGET,mode = "sens_spec",positive = "pos")
