# Lo script unisce la tabella degli scontrini a quella di coswin,
# aggiungendo le colonne chiamata e chiamata-x dove x sono i giorni precedenti
# all'effettiva chiamata
#importa tabella degli scontrini
df <-
read.csv2(file = "tabella_scontrini_allarmi.csv",
header = T,
stringsAsFactors = F)
#conversione date e factors
df[,c(2,4:ncol(df))] %<>% lapply(function(x) factor(x))
df$INIZIO.CICLO <-
parse_date_time(df$INIZIO.CICLO, orders = "dmy hms")
esquisse::esquisser()
library(tidyverse)
library(dplyr)
library(lubridate)
library(here)
library(readxl)
library(magrittr)
library(DataExplorer)
library(caret)
library(rlist)
library(nnet)
library(NeuralNetTools)
library(esquisse)
# library(pROC)
# Lo script unisce la tabella degli scontrini a quella di coswin,
# aggiungendo le colonne chiamata e chiamata-x dove x sono i giorni precedenti
# all'effettiva chiamata
#importa tabella degli scontrini
df <-
read.csv2(file = "tabella_scontrini_allarmi.csv",
header = T,
stringsAsFactors = F)
#conversione date e factors
df[,c(2,4:ncol(df))] %<>% lapply(function(x) factor(x))
df$INIZIO.CICLO <-
parse_date_time(df$INIZIO.CICLO, orders = "dmy hms")
# esquisse::esquisser()
#quanto tempo passa tra un ciclo irregolare e l'altro? ####
# df_irregolari <- df[which(df$CICLO.REGOLARE == "0"),]
#
# col1 <- seq(1, 548, by = 2)
# time1 <- df_irregolari[col1,]
#
# time2 <- df_irregolari[-col1,]
#
# timediff <-
#   difftime(time2$INIZIO.CICLO, time1$INIZIO.CICLO, units = "days")
# summary(as.numeric(timediff))
# hist(as.numeric(timediff), main = "Distribuzione delle differenze temporali tra cicli irregolari\n in giorni")
# table(as.numeric(timediff))
# difftime(time2[274, 1], time1[274, 1])
#
# timetable <- data.frame(
#   "t1" = time1$INIZIO.CICLO,
#   "t2" = time2$INIZIO.CICLO,
#   "timediff" = timediff
# ) %>% .[order(.$timediff, decreasing = T), ]
# head(timetable)
# summary(as.numeric(timediff))
#caricamento coswin####
# vengono eliminate le righe corrispondenti a chiamate relative all'inserimento
# nel db della macchina di un nuovo strumento.
coswin <- read.csv2(file = "coswin-isa/108841.csv",
header = T,
stringsAsFactors = F) %>%
.[-which(grepl("inseri|verifica|ordinaria", x = .$Descrizione,ignore.case = T)),24] %>%
as.character(.) %>%
dmy_hm(.) %>%
as_date(.) %>%
.[which(complete.cases(.))] %>%
unique(.)
#aggiunta colonna dei giorni nella tabella di scontrini
df <- df %>%
mutate("GIORNO" = as_date(.$INIZIO.CICLO))
#aggiunta della colonna CHIAMATA nella tabella degli scontrini
#l'istanza avrà CHIAMATA = 1 se il giorno corrisponde ad una delle date in coswin
#aggiunta della bag-label
df <- df %>%
mutate("CHIAMATA" = factor(ifelse(.$GIORNO %in% coswin, 1, 0)))
# "BAG"=factor(cut.Date(df$GIORNO, breaks = "5 days",labels = F)))
ignore_columns <- c("testo","TEST.DI.TENUTA","NUMERO.CICLO",
"INIZIO.CICLO")
df <- df[,-which(names(df) %in% ignore_columns)]
#conversione multipla delle feature da int a fattori
# cols = c(38:86,88, 2)
# df[,cols] %<>% lapply(function(x) fct_explicit_na(as.character(x)))
# df%<>%.[,-c(3,6:37)]
#
#trovo i giorni in cui ci sono state chiamate a coswin
giorni_guasti <- unique(df[which(df$CHIAMATA==1),which(colnames(df)=="GIORNO")])
#trovo le date dei 5 giorni precedenti ad ognuno dei giorni appena trovati
# attraverso la funzione backprop
backprop <- function(giorno){
as.list(seq(from=giorno-1,to =giorno-5,by = -1))
}
giorni_predittivi <- sapply(giorni_guasti, backprop)
# assegno flag=1 in corrispondenza dei giorni predittivi
df%<>%mutate(flag=ifelse(as.Date(df$GIORNO)%in%giorni_predittivi,1,0))
df_pos <- df[which(df$flag==1),] %>%
mutate("BAG"=factor(cut.Date(.$GIORNO, breaks = "5 days",labels = F)))
df_pos_bag <- as.list(split(df_pos,f = df_pos$BAG))
#le righe con flag=1 sono le bag positive
#bag "negative", separate in bags da 5 giorni
df_neg <- df[-which(df$flag==1),] %>%
mutate("BAG"=factor(cut.Date(.$GIORNO, breaks = "5 days",labels = F)))
df_neg_bag <- as.list(split(df_neg,f = df_neg$BAG))
# assegno ad ogni elemento delle bag create il flag 1 o 0
df_pos_bag <- lapply(df_pos_bag,function(x) list("INSTANCES"=x,
"BAG_FLAG"=1))
df_neg_bag <- lapply(df_neg_bag,function(x) list("INSTANCES"=x,
"BAG_FLAG"=0))
# divido in train e test
train_pos <- sample(df_pos_bag, length(df_pos_bag)*0.75,replace = F)
train_neg <- sample(df_neg_bag, length(df_neg_bag)*0.75,replace = F)
train <- c(train_pos, train_neg)
test_pos <- sample(df_pos_bag, length(df_pos_bag)*0.25,replace = F)
test_neg <- sample(df_neg_bag, length(df_neg_bag)*0.25,replace = F)
test <- c(test_pos, test_neg)
#shuffling finale
train <- sample(train, length(train), replace = T)
test <- sample(test, length(test),replace=T)
train <- lapply(train, function(x) {
list("INSTANCES"=x$INSTANCES[,-which(names(x$INSTANCES) %in% c("BAG","CHIAMATA", "GIORNO"))],
"BAG_FLAG"=x$BAG_FLAG)
})
freq_factor <- function(factor_column){
tt <- table(factor_column)
return(names(tt[which.max(tt)]))
}
unify_alarms <- function(alarm_column){
ifelse(1 %in% alarm_column,return(levels(alarm_column)[1]),return(levels(alarm_column)[2]))
}
meta <- function(df_instances){
temps_columns <- grep("temp\\.",names(df_instances))
alarm_columns <- grep("allarm|alarm",names(df_instances),ignore.case = T)
fct <- summarise_all(df_instances[,-c(temps_columns,alarm_columns)],funs(freq_factor(.)))
temps <- summarise_all(df_instances[,temps_columns],mean,na.rm=T)
alarms <- summarise_all(df_instances[,alarm_columns], funs(unify_alarms(.)))
TARGET <- 1
return(cbind(fct,temps,alarms,TARGET))
}
df_meta <- lapply(train,FUN = function(bag){
if(bag$BAG_FLAG==1){
meta_example <- meta(bag$INSTANCES)
} else{
examples <- cbind(bag$INSTANCES, TARGET=0)
}
}) %>% do.call("rbind",.)
df_meta_pp <- df_meta %>% mutate_each_(funs(factor(.)),c(1:37)) %>%
.[, sapply(., function(col) length(unique(col))) > 1]
df_meta <- lapply(train,FUN = function(bag){
if(bag$BAG_FLAG==1){
meta_example <- meta(bag$INSTANCES)
} else{
examples <- cbind(bag$INSTANCES, TARGET=0)
}
}) %>% do.call("rbind",.)
df_meta_pp <- df_meta[,-which(names(df_meta) %in% c("BAG","CHIAMATA", "GIORNO","flag"))]
# View(colnames(df_meta_pp))
df_meta_pp$TARGET <- as.numeric(df_meta_pp$TARGET)
df_meta_pp$temp.1 <- as.numeric(df_meta_pp$temp.1)
df_meta_pp$temp.2 <- as.numeric(df_meta_pp$temp.2)
# df_meta_pp[,-which(names(df_meta_pp)%in%"TARGET")] <- factor(df_meta_pp[,-which(names(df_meta_pp)%in%"TARGET")])
dummies <- dummyVars(~.,data = df_meta_pp,fullRank = T)
dummied <- as.data.frame(predict(dummies, newdata = df_meta_pp))
df_meta_pp <- dummied
sapply(df_meta_pp,function(col) length(unique(col)))
library(tidyverse)
library(dplyr)
library(lubridate)
library(here)
library(readxl)
library(magrittr)
library(DataExplorer)
library(caret)
library(rlist)
library(nnet)
library(NeuralNetTools)
library(esquisse)
# library(pROC)
# Lo script unisce la tabella degli scontrini a quella di coswin,
# aggiungendo le colonne chiamata e chiamata-x dove x sono i giorni precedenti
# all'effettiva chiamata
#importa tabella degli scontrini
df <-
read.csv2(file = "tabella_scontrini_allarmi.csv",
header = T,
stringsAsFactors = F)
#conversione date e factors
df[,c(2,4:ncol(df))] %<>% lapply(function(x) factor(x))
df$INIZIO.CICLO <-
parse_date_time(df$INIZIO.CICLO, orders = "dmy hms")
# esquisse::esquisser()
#quanto tempo passa tra un ciclo irregolare e l'altro? ####
# df_irregolari <- df[which(df$CICLO.REGOLARE == "0"),]
#
# col1 <- seq(1, 548, by = 2)
# time1 <- df_irregolari[col1,]
#
# time2 <- df_irregolari[-col1,]
#
# timediff <-
#   difftime(time2$INIZIO.CICLO, time1$INIZIO.CICLO, units = "days")
# summary(as.numeric(timediff))
# hist(as.numeric(timediff), main = "Distribuzione delle differenze temporali tra cicli irregolari\n in giorni")
# table(as.numeric(timediff))
# difftime(time2[274, 1], time1[274, 1])
#
# timetable <- data.frame(
#   "t1" = time1$INIZIO.CICLO,
#   "t2" = time2$INIZIO.CICLO,
#   "timediff" = timediff
# ) %>% .[order(.$timediff, decreasing = T), ]
# head(timetable)
# summary(as.numeric(timediff))
#caricamento coswin####
# vengono eliminate le righe corrispondenti a chiamate relative all'inserimento
# nel db della macchina di un nuovo strumento.
coswin <- read.csv2(file = "coswin-isa/108841.csv",
header = T,
stringsAsFactors = F) %>%
.[-which(grepl("inseri|verifica|ordinaria", x = .$Descrizione,ignore.case = T)),24] %>%
as.character(.) %>%
dmy_hm(.) %>%
as_date(.) %>%
.[which(complete.cases(.))] %>%
unique(.)
#aggiunta colonna dei giorni nella tabella di scontrini
df <- df %>%
mutate("GIORNO" = as_date(.$INIZIO.CICLO))
#aggiunta della colonna CHIAMATA nella tabella degli scontrini
#l'istanza avrà CHIAMATA = 1 se il giorno corrisponde ad una delle date in coswin
#aggiunta della bag-label
df <- df %>%
mutate("CHIAMATA" = factor(ifelse(.$GIORNO %in% coswin, 1, 0)))
# "BAG"=factor(cut.Date(df$GIORNO, breaks = "5 days",labels = F)))
ignore_columns <- c("testo","TEST.DI.TENUTA","NUMERO.CICLO",
"INIZIO.CICLO")
df <- df[,-which(names(df) %in% ignore_columns)]
#conversione multipla delle feature da int a fattori
# cols = c(38:86,88, 2)
# df[,cols] %<>% lapply(function(x) fct_explicit_na(as.character(x)))
# df%<>%.[,-c(3,6:37)]
#
#trovo i giorni in cui ci sono state chiamate a coswin
giorni_guasti <- unique(df[which(df$CHIAMATA==1),which(colnames(df)=="GIORNO")])
#trovo le date dei 5 giorni precedenti ad ognuno dei giorni appena trovati
# attraverso la funzione backprop
backprop <- function(giorno){
as.list(seq(from=giorno-1,to =giorno-5,by = -1))
}
giorni_predittivi <- sapply(giorni_guasti, backprop)
# assegno flag=1 in corrispondenza dei giorni predittivi
df%<>%mutate(flag=ifelse(as.Date(df$GIORNO)%in%giorni_predittivi,1,0))
df_pos <- df[which(df$flag==1),] %>%
mutate("BAG"=factor(cut.Date(.$GIORNO, breaks = "5 days",labels = F)))
df_pos_bag <- as.list(split(df_pos,f = df_pos$BAG))
#le righe con flag=1 sono le bag positive
#bag "negative", separate in bags da 5 giorni
df_neg <- df[-which(df$flag==1),] %>%
mutate("BAG"=factor(cut.Date(.$GIORNO, breaks = "5 days",labels = F)))
df_neg_bag <- as.list(split(df_neg,f = df_neg$BAG))
# assegno ad ogni elemento delle bag create il flag 1 o 0
df_pos_bag <- lapply(df_pos_bag,function(x) list("INSTANCES"=x,
"BAG_FLAG"=1))
df_neg_bag <- lapply(df_neg_bag,function(x) list("INSTANCES"=x,
"BAG_FLAG"=0))
# divido in train e test
train_pos <- sample(df_pos_bag, length(df_pos_bag)*0.75,replace = F)
train_neg <- sample(df_neg_bag, length(df_neg_bag)*0.75,replace = F)
train <- c(train_pos, train_neg)
test_pos <- sample(df_pos_bag, length(df_pos_bag)*0.25,replace = F)
test_neg <- sample(df_neg_bag, length(df_neg_bag)*0.25,replace = F)
test <- c(test_pos, test_neg)
#shuffling finale
train <- sample(train, length(train), replace = T)
test <- sample(test, length(test),replace=T)
#trasformazione di train nel dataframe di learning ####
train <- lapply(train, function(x) {
list("INSTANCES"=x$INSTANCES[,-which(names(x$INSTANCES) %in% c("BAG","CHIAMATA", "GIORNO"))],
"BAG_FLAG"=x$BAG_FLAG)
})
#ciclando sulle bags, se il flag è 0, tutte le istances diventano esempi,
#se il flag è 1, viene creato un metaesempio tramite la funzione meta.
#la funzione "meta" prende in ingresso un dataframe e riporta in uscita
# un unico vettore con lo stesso numero di colonne del dataframe iniziale
# ma con un'unica riga. Il vettore rappresenta una "media" di tutte le righe
# presenti nel dataframe iniziale, diventando così un meta-esempio da inserire nel
# dataset di esempi.
# Se la variabile è categorica, viene utilizzata la funzione freq_factor
# ed il meta-esempio assumerà in quella variabile il valore più frequente
# altrimenti, se la variabile è numerica, viene calcolata la media aritmetica
# Nel caso delle variabili di allarme, la funzione meta assegnerà al meta-esempio
# il valore 1 se almeno una delle instances presenta valore 1 nella corrispettiva
# colonna di allarme, 0 altrimenti.
freq_factor <- function(factor_column){
tt <- table(factor_column)
return(names(tt[which.max(tt)]))
}
unify_alarms <- function(alarm_column){
ifelse(1 %in% alarm_column,return(levels(alarm_column)[1]),return(levels(alarm_column)[2]))
}
meta <- function(df_instances){
temps_columns <- grep("temp\\.",names(df_instances))
alarm_columns <- grep("allarm|alarm",names(df_instances),ignore.case = T)
fct <- summarise_all(df_instances[,-c(temps_columns,alarm_columns)],funs(freq_factor(.)))
temps <- summarise_all(df_instances[,temps_columns],mean,na.rm=T)
alarms <- summarise_all(df_instances[,alarm_columns], funs(unify_alarms(.)))
TARGET <- 1
return(cbind(fct,temps,alarms,TARGET))
}
df_meta <- lapply(train,FUN = function(bag){
if(bag$BAG_FLAG==1){
meta_example <- meta(bag$INSTANCES)
} else{
examples <- cbind(bag$INSTANCES, TARGET=0)
}
}) %>% do.call("rbind",.)
df_meta_pp <- df_meta[,-which(names(df_meta) %in% c("BAG","CHIAMATA", "GIORNO","flag"))]
# View(colnames(df_meta_pp))
df_meta_pp$TARGET <- as.numeric(df_meta_pp$TARGET)
df_meta_pp$temp.1 <- as.numeric(df_meta_pp$temp.1)
df_meta_pp$temp.2 <- as.numeric(df_meta_pp$temp.2)
sapply(df_meta_pp,function(col) length(unique(col)))
df_meta_pp%<>%.[,sapply(df_meta_pp,function(col) length(unique(col)))>1]
df_meta_pp%<>%.[,sapply(df_meta_pp,function(col) length(unique(col)))>1]
sapply(df_meta_pp,function(col) length(unique(col)))>1
table(df_meta_pp$allarme ALLARME.LIVELLO.VASCA.)
table(df_meta_pp$ALLARME.LIVELLO.VASCA.)
df_meta_pp%<>%.[,sapply(df_meta_pp,function(col) length(unique(col)))>2]
df_meta_pp%<>%.[,sapply(df_meta_pp,function(col) length(unique(col)))>1]
library(tidyverse)
library(dplyr)
library(lubridate)
library(here)
library(readxl)
library(magrittr)
library(DataExplorer)
library(caret)
library(rlist)
library(nnet)
library(NeuralNetTools)
library(esquisse)
# library(pROC)
# Lo script unisce la tabella degli scontrini a quella di coswin,
# aggiungendo le colonne chiamata e chiamata-x dove x sono i giorni precedenti
# all'effettiva chiamata
#importa tabella degli scontrini
df <-
read.csv2(file = "tabella_scontrini_allarmi.csv",
header = T,
stringsAsFactors = F)
#conversione date e factors
df[,c(2,4:ncol(df))] %<>% lapply(function(x) factor(x))
df$INIZIO.CICLO <-
parse_date_time(df$INIZIO.CICLO, orders = "dmy hms")
# esquisse::esquisser()
#quanto tempo passa tra un ciclo irregolare e l'altro? ####
# df_irregolari <- df[which(df$CICLO.REGOLARE == "0"),]
#
# col1 <- seq(1, 548, by = 2)
# time1 <- df_irregolari[col1,]
#
# time2 <- df_irregolari[-col1,]
#
# timediff <-
#   difftime(time2$INIZIO.CICLO, time1$INIZIO.CICLO, units = "days")
# summary(as.numeric(timediff))
# hist(as.numeric(timediff), main = "Distribuzione delle differenze temporali tra cicli irregolari\n in giorni")
# table(as.numeric(timediff))
# difftime(time2[274, 1], time1[274, 1])
#
# timetable <- data.frame(
#   "t1" = time1$INIZIO.CICLO,
#   "t2" = time2$INIZIO.CICLO,
#   "timediff" = timediff
# ) %>% .[order(.$timediff, decreasing = T), ]
# head(timetable)
# summary(as.numeric(timediff))
#caricamento coswin####
# vengono eliminate le righe corrispondenti a chiamate relative all'inserimento
# nel db della macchina di un nuovo strumento.
coswin <- read.csv2(file = "coswin-isa/108841.csv",
header = T,
stringsAsFactors = F) %>%
.[-which(grepl("inseri|verifica|ordinaria", x = .$Descrizione,ignore.case = T)),24] %>%
as.character(.) %>%
dmy_hm(.) %>%
as_date(.) %>%
.[which(complete.cases(.))] %>%
unique(.)
#aggiunta colonna dei giorni nella tabella di scontrini
df <- df %>%
mutate("GIORNO" = as_date(.$INIZIO.CICLO))
#aggiunta della colonna CHIAMATA nella tabella degli scontrini
#l'istanza avrà CHIAMATA = 1 se il giorno corrisponde ad una delle date in coswin
#aggiunta della bag-label
df <- df %>%
mutate("CHIAMATA" = factor(ifelse(.$GIORNO %in% coswin, 1, 0)))
# "BAG"=factor(cut.Date(df$GIORNO, breaks = "5 days",labels = F)))
ignore_columns <- c("testo","TEST.DI.TENUTA","NUMERO.CICLO",
"INIZIO.CICLO")
df <- df[,-which(names(df) %in% ignore_columns)]
#conversione multipla delle feature da int a fattori
# cols = c(38:86,88, 2)
# df[,cols] %<>% lapply(function(x) fct_explicit_na(as.character(x)))
# df%<>%.[,-c(3,6:37)]
#
#trovo i giorni in cui ci sono state chiamate a coswin
giorni_guasti <- unique(df[which(df$CHIAMATA==1),which(colnames(df)=="GIORNO")])
#trovo le date dei 5 giorni precedenti ad ognuno dei giorni appena trovati
# attraverso la funzione backprop
backprop <- function(giorno){
as.list(seq(from=giorno-1,to =giorno-5,by = -1))
}
giorni_predittivi <- sapply(giorni_guasti, backprop)
# assegno flag=1 in corrispondenza dei giorni predittivi
df%<>%mutate(flag=ifelse(as.Date(df$GIORNO)%in%giorni_predittivi,1,0))
df_pos <- df[which(df$flag==1),] %>%
mutate("BAG"=factor(cut.Date(.$GIORNO, breaks = "5 days",labels = F)))
df_pos_bag <- as.list(split(df_pos,f = df_pos$BAG))
#le righe con flag=1 sono le bag positive
#bag "negative", separate in bags da 5 giorni
df_neg <- df[-which(df$flag==1),] %>%
mutate("BAG"=factor(cut.Date(.$GIORNO, breaks = "5 days",labels = F)))
df_neg_bag <- as.list(split(df_neg,f = df_neg$BAG))
# assegno ad ogni elemento delle bag create il flag 1 o 0
df_pos_bag <- lapply(df_pos_bag,function(x) list("INSTANCES"=x,
"BAG_FLAG"=1))
df_neg_bag <- lapply(df_neg_bag,function(x) list("INSTANCES"=x,
"BAG_FLAG"=0))
# divido in train e test
train_pos <- sample(df_pos_bag, length(df_pos_bag)*0.75,replace = F)
train_neg <- sample(df_neg_bag, length(df_neg_bag)*0.75,replace = F)
train <- c(train_pos, train_neg)
test_pos <- sample(df_pos_bag, length(df_pos_bag)*0.25,replace = F)
test_neg <- sample(df_neg_bag, length(df_neg_bag)*0.25,replace = F)
test <- c(test_pos, test_neg)
#shuffling finale
train <- sample(train, length(train), replace = T)
test <- sample(test, length(test),replace=T)
#trasformazione di train nel dataframe di learning ####
train <- lapply(train, function(x) {
list("INSTANCES"=x$INSTANCES[,-which(names(x$INSTANCES) %in% c("BAG","CHIAMATA", "GIORNO"))],
"BAG_FLAG"=x$BAG_FLAG)
})
#ciclando sulle bags, se il flag è 0, tutte le istances diventano esempi,
#se il flag è 1, viene creato un metaesempio tramite la funzione meta.
#la funzione "meta" prende in ingresso un dataframe e riporta in uscita
# un unico vettore con lo stesso numero di colonne del dataframe iniziale
# ma con un'unica riga. Il vettore rappresenta una "media" di tutte le righe
# presenti nel dataframe iniziale, diventando così un meta-esempio da inserire nel
# dataset di esempi.
# Se la variabile è categorica, viene utilizzata la funzione freq_factor
# ed il meta-esempio assumerà in quella variabile il valore più frequente
# altrimenti, se la variabile è numerica, viene calcolata la media aritmetica
# Nel caso delle variabili di allarme, la funzione meta assegnerà al meta-esempio
# il valore 1 se almeno una delle instances presenta valore 1 nella corrispettiva
# colonna di allarme, 0 altrimenti.
freq_factor <- function(factor_column){
tt <- table(factor_column)
return(names(tt[which.max(tt)]))
}
unify_alarms <- function(alarm_column){
ifelse(1 %in% alarm_column,return(levels(alarm_column)[1]),return(levels(alarm_column)[2]))
}
meta <- function(df_instances){
temps_columns <- grep("temp\\.",names(df_instances))
alarm_columns <- grep("allarm|alarm",names(df_instances),ignore.case = T)
fct <- summarise_all(df_instances[,-c(temps_columns,alarm_columns)],funs(freq_factor(.)))
temps <- summarise_all(df_instances[,temps_columns],mean,na.rm=T)
alarms <- summarise_all(df_instances[,alarm_columns], funs(unify_alarms(.)))
TARGET <- 1
return(cbind(fct,temps,alarms,TARGET))
}
df_meta <- lapply(train,FUN = function(bag){
if(bag$BAG_FLAG==1){
meta_example <- meta(bag$INSTANCES)
} else{
examples <- cbind(bag$INSTANCES, TARGET=0)
}
}) %>% do.call("rbind",.)
df_meta_pp <- df_meta[,-which(names(df_meta) %in% c("BAG","CHIAMATA", "GIORNO","flag"))]
# View(colnames(df_meta_pp))
df_meta_pp$TARGET <- as.numeric(df_meta_pp$TARGET)
df_meta_pp$temp.1 <- as.numeric(df_meta_pp$temp.1)
df_meta_pp$temp.2 <- as.numeric(df_meta_pp$temp.2)
# pre processing ####
#one-hot encoding
df_meta_pp%<>%.[,sapply(df_meta_pp,function(col) length(unique(col)))>1]
sapply(df_meta_pp,function(col) length(unique(col)))
sapply(df_meta_pp,function(col) nlevels(col))
df_meta_pp%<>%.[,sapply(df_meta_pp,function(col) nlevels(col))>1]
is.factor(df$TIPO.CICLO)
df_meta_pp <- df_meta[,-which(names(df_meta) %in% c("BAG","CHIAMATA", "GIORNO","flag"))]
# View(colnames(df_meta_pp))
df_meta_pp$TARGET <- as.numeric(df_meta_pp$TARGET)
df_meta_pp$temp.1 <- as.numeric(df_meta_pp$temp.1)
df_meta_pp$temp.2 <- as.numeric(df_meta_pp$temp.2)
df_meta_pp <- df_meta[,-which(names(df_meta) %in% c("BAG","CHIAMATA", "GIORNO","flag"))]
# View(colnames(df_meta_pp))
df_meta_pp$TARGET <- as.numeric(df_meta_pp$TARGET)
df_meta_pp$temp.1 <- as.numeric(df_meta_pp$temp.1)
df_meta_pp$temp.2 <- as.numeric(df_meta_pp$temp.2)
# pre processing ####
#one-hot encoding
df_meta_pp%<>%.[,sapply(df_meta_pp,function(col) if(is.factor(col)){
if(nlevels(col)>1)}]
sapply(df_meta_pp,function(col) if(is.factor(col)){
if(nlevels(col)>1)}
